Angular представляет фреймворк от компании Google для создания клиентских приложений. 
Прежде всего он нацелен на разработку SPA-решений (Single Page Application), 
то есть одностраничных приложений. В этом плане Angular является наследником 
другого фреймворка AngularJS. В то же время Angular 
это не новая версия AngularJS, а принципиально новый фреймворк.

Angular 5 предоставляет такую функциональность, как двустороннее связывание, 
позволяющее динамически изменять данные в одном месте интерфейса при изменении 
данных модели в другом, шаблоны, маршрутизация и так далее.

Одной из ключевых особенностей Angular является то, что он использует в качестве языка 
программирования TypeScript. Поэтому перед началом работы рекомендуется ознакомиться с 
основами данного языка, про которые можно прочитать здесь.

Но мы не ограничены языком TypeScript. При желании можем писать 
приложения на Angular с помощью таких языков как Dart или JavaScript. 
Однако TypeScript все таки является основным языком для Angular.

Последняя версия Angular - Angular 6 вышла в мае 2018 года. Официальный репозиторий
 фреймворка на гитхабе: https://github.com/angular/angular. 
 Там вы можете найти сами исходные файлы, а также некоторую 
 дополнительную информацию.

Начало работы c Angular

Для работы с Angular необходимо установить сервер Node.js и пакетный менеджер npm, 
если они отсутствуют на рабочей машине. 
Для установки можно использовать программу установки node.js.
Вместе с сервером она также установить и npm. При этом особого какого-то знания для работы с NodeJS и npm не требуется.

После установки необходимых инструментов создадим простейшее приложение. 
Для этого определим на жестком диске папку приложения.
 Путь она будет называться helloapp. В этой папке создадим 
 новый файл package.json со следующим содержимым:

{
    "name": "helloapp",
    "version": "1.0.0",
    "description": "First Angular 6 Project",
    "author": "Eugene Popov <metanit.com>",
    "scripts": {
        "dev": "webpack-dev-server --hot --open",
        "build": "webpack"
    },
    "dependencies": {
    "@angular/common": "~6.0.0",
    "@angular/compiler": "~6.0.0",
    "@angular/core": "~6.0.0",
    "@angular/forms": "~6.0.0",
    "@angular/platform-browser": "~6.0.0",
    "@angular/platform-browser-dynamic": "~6.0.0",
    "@angular/router": "~6.0.0",
    "core-js": "2.5.7",
    "rxjs":"6.2.2",
    "zone.js": "0.8.26"
  },
  "devDependencies": {
    "@types/node":"10.5.2",
    "typescript": "2.9.2",
    "webpack": "4.16.1",
    "webpack-cli": "3.1.0",
    "webpack-dev-server": "3.1.4",
    "angular2-template-loader": "0.6.2",
    "awesome-typescript-loader": "5.2.0",
    "uglifyjs-webpack-plugin": "1.2.7"
  }
}

Данный файл устанавливает пакеты и зависимости, которые будут использоваться проектом.
В секции dependencies в основном определяются пакеты angular,
 которые необходимы приложению для работы. В секции devDependencies 
 прописаны только те пакеты, которые будут использоваться для разработки. 
 В частности, это пакеты для работы с языком typescript (так как мы будем писать код приложения на языке TypeScript), 
 а также пакеты, необходимые для сборки приложения в один 
 файл с помощью сборщика webpack.

Затем откроем командную строку (терминал) и перейдем в ней к папке проекта с помощью команды cd:

C:\WINDOWS\system32>cd C:\angular2\helloapp
И затем выполним команду npm install, которая установит все необходимые модули:

C:\angular2\helloapp>npm install
После выполнения этой команды в папке проекта должна появиться подпапка node_modules, которая содержит все используемые зависимости и пакеты.

Затем создадим в папке проекта подпапку, которую назовем src - она будет содержать все исходные файлы. И далее в папке src создадим подкаталог app.

Создание компонента Angular
Компоненты представляют основные строительные блоки приложения Angular 2. Каждое приложение Angular имеет как минимум один компонент. Поэтому создадим в папке src/app новый файл, который назовем app.component.ts и в котором определим следующий код компонента:
import { Component } from '@angular/core';
     
@Component({
    selector: 'my-app',
    template: `<label>Введите имя:</label>
                 <input [(ngModel)]="name" placeholder="name">
                 <h1>Добро пожаловать {{name}}!</h1>`
})
export class AppComponent { 
    name= '';
}

В начале файла определяется директива import, которая импортирует функциональность модуля angular/core, предоставляя доступ к функции декоратора @Component.

Далее собственно идет функция-декоратор @Component, которая ассоциирует метаданные с классом компонента AppComponent. В этой функции, во-первых, определяется параметр selector или селектор css для HTML-элемента, который будет представлять компонент. Во-вторых, здесь определяется параметр template или шаблон, который указывает, как надо визуализировать компонент. В этом шаблоне задана двусторонняя привязка с помощью выражений [(ngModel)]="name" и {{name}} к некоторой модели name.

И в конце собственно экспортируется класс компонента AppComponent, в котором как раз определяется модель name - в данном случае это пустая строка.

Создание модуля приложения
Приложение Angular состоит из модулей. Модульная структура позволяет легко подгружать и задействовать только те модули, которые непосредственно необходимы. И каждое приложение имеет как минимум один корневой модуль. Поэтому создадим в папке src/app новый файл, который назовем app.module.ts со следующим содержимым:


import { NgModule }      from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { FormsModule }   from '@angular/forms';
import { AppComponent }   from './app.component';
@NgModule({
    imports:      [ BrowserModule, FormsModule ],
    declarations: [ AppComponent ],
    bootstrap:    [ AppComponent ]
})
export class AppModule { }

Этот модуль, который в данном случае называется AppModule, будет входной точкой в приложение.

С помощью директив import здесь импортируется ряд нужных нам модулей. Прежде всего, это модуль NgModule. Для работы с браузером также требуется модуль BrowserModule. Так как наш компонент использует элемент input или элемент формы, то также подключаем модуль FormsModule. И далее импортируется созданный ранее компонент.

Запуск приложения
Теперь нам надо указать Angularу, как запускать наше приложение. Для этого создадим в папке src (на уровень выше, чем расположены файлы app.component.ts и app.module.ts) файл main.ts со следующим содержимым:

import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
import { AppModule } from './app/app.module';
const platform = platformBrowserDynamic();
platform.bootstrapModule(AppModule);

Этот код инициализирует платформу, которая запускает приложение, и затем использует эту платформу для загрузки модуля AppModule.

Также в папке src определим еще один файл, который назовем polyfills.ts со следующим кодом:

import 'core-js/es6';
// для поддержки Reflect Api
import 'core-js/es7/reflect';
// zone используется angular
import 'zone.js/dist/zone';

Данный файл определяет полифилы - инструменты, которые необходимы для поддержки приложения на Angular старыми браузерами. В частности, первая большая группа полифилов предназвачена для работы в IE9-11. Однако если мы не планируем поддерживать этот браузер, то данную группу импорта пакетов можно не включать. Но в любом случае файл должен содержать импорт zone: import 'zone.js/dist/zone'.

Определение конфигурации
Поскольку для определения кода приложения применяется язык TypeScript, поэтому также создадим в корневой папке проекта новый файл tsconfig.json:

{
    "compilerOptions": {
      "target": "es5",
      "module": "es2015",
      "moduleResolution": "node",
      "sourceMap": true,
      "emitDecoratorMetadata": true,
      "experimentalDecorators": true,
      "lib": [ "es2015", "dom" ],
      "noImplicitAny": true,
      "suppressImplicitAnyIndexErrors": true,
      "typeRoots": [
        "node_modules/@types/"
      ]
    },
    "exclude": [
        "node_modules"
    ]
  }

Данный файл определяет настройки для компилятора TypeScript. Опция "compilerOptions" устанавливает параметры компиляции. А опция "exclude" исключает из компиляции папку node_modules, которая содержит все загруженные пакеты.

Если мы используем TypeScript для работы с Angular, то эти два файла фактически будут присутствовать в каждом проекте. И их можно переносить из проекта в проект с минимальными изменениями. Например, в файле package.json можно будет задать какие-то другие версии пакетов, если предыдущие версии устарели. Можно будет изменить название проекта, версию. Можно подправить настройки TypeScript, но в целом общая организация будет той же.

Поскольку наше приложение будет разбито на несколько отдельных файлов, то для их сборки будем использовать популярняй сборщик webpack. Поэтому также определим в корневой папке проекта еще один файл webpack.config.js:


var path = require('path');
var webpack = require('webpack');
var UglifyJSPlugin = require('uglifyjs-webpack-plugin'); // плагин минимизации
module.exports = {
    entry: {
        'polyfills': './src/polyfills.ts',
        'app': './src/main.ts'
      },
   output:{
       path: path.resolve(__dirname, './public'),     // путь к каталогу выходных файлов - папка public
       publicPath: '/public/',
       filename: "[name].js"       // название создаваемого файла
   },
   resolve: {
    extensions: ['.ts', '.js']
  },
   module:{
       rules:[   //загрузчик для ts
           {
               test: /\.ts$/, // определяем тип файлов
               use: [
                {
                    loader: 'awesome-typescript-loader',
                    options: { configFileName: path.resolve(__dirname, 'tsconfig.json') }
                  } ,
                   'angular2-template-loader'
               ]
            }
       ]
   },
   plugins: [
    new webpack.ContextReplacementPlugin(
        /angular(\\|\/)core/,
        path.resolve(__dirname, 'src'), // каталог с исходными файлами
      {} // карта маршрутов
    ),
    new UglifyJSPlugin()
  ]
}

Данный файл предоставляет информацию загрузчику модулей о том, где искать модули приложения, а также регистрирует все необходимые пакеты.

В данном случае я не буду подробно разбирать конфигурацию webpack, так как она более подробно разбирается в соответствующей теме. Отмечу только основные моменты. В секции entry определяются входные файлы для компиляции и имена сборок. В данном случае для файла "src/polyfills.ts" будет создаваться сборка "polyfills", а из файла "src/main.ts" (который в свою очередь подтягивает другие файлы приложения) будет комилироваться сборка "app".

В секции output определяется, что сборки будут находиться в каталоге public, и для них будут созданы файлы с названиями сборок. Плейсхолдер [name] будет передать название сборки, то есть polyfills или app.

В секции resolve указываются расширения, которые будут применяться к модулям в файлах typescript.

Секция module.rules определяет загрузчики файлов typescript, которые будут использоваться для сборки проекта. По умолчанию Webpack понимает только файлы javascript, поэтому для файлов ts необходимы специальные инструменты - загрузчики. Здесь для загрузки файлов typescript применяются загрузчики awesome-typescript-loader и angular2-template-loader.

Последняя часть файла - секция plugins определяет плагины - вспомогательные инструменты, которые применяются при сборке. В частности, плагин webpack.ContextReplacementPlugin позволяет управлять путями к файлам вне зависимости используем мы Windows или Linux. Плагин UglifyJsPlugin минифицирует код сборок.

Создание главной страницы
В конце определим главную страницу index.html в корневой папке проекта:


<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Hello Angular 6</title>
</head>
<body>
    <my-app>Загрузка...</my-app>
    <script src="public/polyfills.js"></script>
    <script src="public/app.js"></script>
</body>
</html>

А в элементе body определен элемент <my-app>, в который собственно и будет загружаться приложение.

Далее подгружаются скомпилированные и собранные с помощью TypeScript и Webpack сборки - polyfills.js и app.js.

В итоге у нас получится следующая структура проекта:
folder helloapp:
	folder src:
		folder app:
			file app.component.ts
			file app.module.ts
		file main.ts
		file polyfills.ts
	<> index.html
	/*package.json
	/*tsconfig.json
	/*webpack.config.json

Angular 5 структура проекта
И теперь, когда все готово, мы можем собрать проект и запустить приложение. Для этого в командной строке (терминале) перейдем к папке проекта с помощью команды cd и затем выполним команду npm run dev:

C:\WINDOWS\system32>cd C:\angular2\helloapp

C:\angular2\helloapp>npm run dev
После этого в веб-браузере будет запущено приложение, и мы сможем протестировать его работу:

Начало работы с Angular 2
Введем в текстовое поле какое-нибудь имя, и оно тут же отобразится в заголовке.



                Первое приложение на Angular
                --------------------------------
Для написания приложений нам потребуется обычный текстовый редактор, хотя можно использовать специальные среды программирования, как Visual Studio, Netbeans, 
WebStorm и другие.

Кроме того, для запуска приложения Angular потребуется веб-сервер. В качестве веб-сервера опять же можно использовать множество различных серверов - Apache, IIS, NodeJS и т.д. В данном случае мы будем опираться на NodeJS.

Итак, создадим на жестком диске папку приложения. Путь она будет называться purchaseApp. В этой папке создадим новый файл package.json со следующим содержимым:

{
    "name": "helloapp",
    "version": "1.0.0",
    "description": "First Angular 6 Project",
    "author": "Eugene Popov <metanit.com>",
    "scripts": {
        "dev": "webpack-dev-server --hot --open",
        "build": "webpack"
    },
    "dependencies": {
    "@angular/common": "~6.0.0",
    "@angular/compiler": "~6.0.0",
    "@angular/core": "~6.0.0",
    "@angular/forms": "~6.0.0",
    "@angular/platform-browser": "~6.0.0",
    "@angular/platform-browser-dynamic": "~6.0.0",
    "@angular/router": "~6.0.0",
    "core-js": "2.5.7",
    "rxjs":"6.2.2",
    "zone.js": "0.8.26"
  },
  "devDependencies": {
    "@types/node":"10.5.2",
    "typescript": "2.9.2",
    "webpack": "4.16.1",
    "webpack-cli": "3.1.0",
    "webpack-dev-server": "3.1.4",
    "angular2-template-loader": "0.6.2",
    "awesome-typescript-loader": "5.2.0",
    "uglifyjs-webpack-plugin": "1.2.7"
  }
}
Также добавим в папку проекта новый файл tsconfig.json:


{
    "compilerOptions": {
      "target": "es5",
      "module": "es2015",
      "moduleResolution": "node",
      "sourceMap": true,
      "emitDecoratorMetadata": true,
      "experimentalDecorators": true,
      "lib": [ "es2015", "dom" ],
      "noImplicitAny": true,
      "suppressImplicitAnyIndexErrors": true,
      "typeRoots": [
        "node_modules/@types/"
      ]
    },
    "exclude": [
        "node_modules"
    ]
}
Как было уже описано в прошлой теме, файл package.json устанавливает пакеты и зависимости, которые будут использоваться проектом.

Файл tsconfig.json устанавливает конфигурацию для компилятора TypeScript.

Для сборки проекта будем использовать сборщик Webpack, поэтому также определим в папке проекта файл webpack.config.js:

1
var path = require('path');
var webpack = require('webpack');
var UglifyJSPlugin = require('uglifyjs-webpack-plugin'); // плагин минимизации
module.exports = {
    entry: {
        'polyfills': './src/polyfills.ts',
        'app': './src/main.ts'
      },
   output:{
       path: path.resolve(__dirname, './public'),     // путь к каталогу выходных файлов - папка public
       publicPath: '/public/',
       filename: "[name].js"       // название создаваемого файла
   },
   resolve: {
    extensions: ['.ts', '.js']
  },
   module:{
       rules:[   //загрузчик для ts
           {
               test: /\.ts$/, // определяем тип файлов
               use: [
                {
                    loader: 'awesome-typescript-loader',
                    options: { configFileName: path.resolve(__dirname, 'tsconfig.json') }
                  } ,
                   'angular2-template-loader'
               ]
            }
       ]
   },
   plugins: [
    new webpack.ContextReplacementPlugin(
        /angular(\\|\/)core/,
        path.resolve(__dirname, 'src'), // каталог с исходными файлами
      {} // карта маршрутов
    ),
    new UglifyJSPlugin()
  ]
}
После создания этих трех файлов в папке проекта откроем командную строку (терминал) и перейдем в ней к папке проекта с помощью команды cd:

C:\WINDOWS\system32>cd C:\angular2\purchaseApp
И затем выполним команду npm install, которая установит все необходимые модули:

C:\angular2\purchaseApp>npm install
После выполнения этой команды в папке проекта должна появиться подпапка node_modules, которая содержит все используемые зависимости и пакеты.

Затем создадим в папке проекта каталог src, а в этом каталоге определим папку app.

В каталог src/app добавим новый файл, который назовем app.component.ts и который будет иметь следующий код:


import { Component } from '@angular/core';
     
class Item{
    purchase: string;
    done: boolean;
    price: number;
     
    constructor(purchase: string, price: number) {
  
        this.purchase = purchase;
        this.price = price;
        this.done = false;
    }
}
 
@Component({
    selector: 'purchase-app',
    template: `<div class="page-header">
        <h1> Список покупок </h1>
    </div>
    <div class="panel">
        <div class="form-inline">
            <div class="form-group">
                <div class="col-md-8">
                    <input class="form-control" [(ngModel)]="text" placeholder = "Название" />
                </div>
            </div>
            <div class="form-group">
                <div class="col-md-6">
                    <input type="number" class="form-control" [(ngModel)]="price" placeholder="Цена" />
                </div>
            </div>
            <div class="form-group">
                <div class="col-md-offset-2 col-md-8">
                    <button class="btn btn-default" (click)="addItem(text, price)">Добавить</button>
                </div>
            </div>
        </div>
        <table class="table table-striped">
            <thead>
                <tr>
                    <th>Предмет</th>
                    <th>Цена</th>
                    <th>Куплено</th>
                </tr>
            </thead>
            <tbody>
                <tr *ngFor="let item of items">
                    <td>{{item.purchase}}</td>
                    <td>{{item.price}}</td>
                    <td><input type="checkbox" [(ngModel)]="item.done" /></td>
                </tr>
            </tbody>
        </table>
    </div>`
})
export class AppComponent { 
    items: Item[] = 
    [
        { purchase: "Хлеб", done: false, price: 15.9 },
        { purchase: "Масло", done: false, price: 60 },
        { purchase: "Картофель", done: true, price: 22.6 },
        { purchase: "Сыр", done: false, price:310 }
    ];
    addItem(text: string, price: number): void {
         
        if(text==null || text.trim()=="" || price==null)
            return;
        this.items.push(new Item(text, price));
    }
}
Первой строкой здесь импортируется функциональность компонента из angular/core.

Для работы нам потребуется вспомогательный класс Item. Этот класс содержит три поля: purchase (название покупки), done (сделана ли покупка) и price (ее цена).

В самом классе компонента определяется начальный список покупок, который будет выводиться на страницу:

items: Item[] = 
    [
        { purchase: "Хлеб", done: false, price: 15.9 },
        { purchase: "Масло", done: false, price: 60 },
        { purchase: "Картофель", done: true, price: 22.6 },
        { purchase: "Сыр", done: false, price:310 }
    ];
И также в классе определен метод добавления в этот список:


addItem(text: string, price: number): void {
         
    if(text==null || text.trim()=="" || price==null)
        return;
    this.items.push(new Item(text, price));
}
Для вывода покупок здесь определен большой шаблон. Вообще подобные большие шаблоны стоит выносить в отдельные файлы, чтобы сделать код компонента проще. Но в нашем случае пусть все пока будет определено в самом компоненте.

В самом шаблоне для вывода данных из массива items в таблицу предусмотрена директива:

1
*ngFor="let item of items"
Кроме того, сверху от таблицы расположена форма для ввода нового объекта Item. А к нажатию кнопки привязан метод addItem() компонента.

Чтобы задействовать этот компонент, добавим в каталог src/app файл модуля app.module.ts:


import { NgModule }      from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { FormsModule }   from '@angular/forms';
import { AppComponent }   from './app.component';
@NgModule({
    imports:      [ BrowserModule, FormsModule ],
    declarations: [ AppComponent ],
    bootstrap:    [ AppComponent ]
})
export class AppModule { }
Уровнем выше в каталоге src определим файл main.ts для запуска проекта:


import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
import { AppModule } from './app/app.module';
const platform = platformBrowserDynamic();
platform.bootstrapModule(AppModule);
Также в каталоге src определим файл polyfills.ts, который необходим для запуска приложения:

1
import 'core-js/es6';
// для поддержки Reflect Api
import 'core-js/es7/reflect';
// zone используется angular
import 'zone.js/dist/zone';

В конце определим главную страницу index.html в корневой папке проекта:


<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Приложение покупок</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
</head>
<body>
    <purchase-app>Загрузка...</purchase-app>
    <script src="public/polyfills.js"></script>
    <script src="public/app.js"></script>
</body>
</html>

В итоге у нас получится следующая структура проекта: see folder 'purchase.json'

Проект Angular 5 и TypeScript
Теперь запустим проект. Для этого в командной строке (терминале) перейдем к папке проекта и затем выполним команду npm run dev:

C:\angular2\purchaseApp>npm run dev
После этого в веб-браузере будет отображена таблица с покупками и форма для добавлени новой покупки

.....................Первое приложение на JavaScript...........................

    

 
В предыдущей теме было создано первое приложение на Angular с применением TypeScript. Использование языка программирования TypeScript представляет наиболее распространенный подход для создания приложений на Angular. Однако это не единственный подход. Теоретически мы можем использовать также Dart, ES2015 и ES5(стандартный JavaScript). И в этой статье рассмотрим создание первого приложения с помощью кода javascript, который поддерживается всеми браузерами.

Создадим каталог приложения, а в нем определим каталог app.

В этот каталог app добавим новый файл app.component.js со следующим кодом:


function Item(purchase, price, done) {
    this.purchase = purchase;
    this.price = price;
    this.done = done;
}
 
var AppComponent = ng.core.Component({
    selector: 'my-app',
    template:  `<div class="page-header">
        <h1> Список покупок </h1>
    </div>
    <div class="panel">
        <div class="form-inline">
            <div class="form-group">
                <div class="col-md-8">
                    <input class="form-control" [(ngModel)]="text" placeholder = "Название" />
                </div>
            </div>
            <div class="form-group">
                <div class="col-md-6">
                    <input type="number" class="form-control" [(ngModel)]="price" placeholder="Цена" />
                </div>
            </div>
            <div class="form-group">
                <div class="col-md-offset-2 col-md-8">
                    <button class="btn btn-default" (click)="addItem(text, price)">Добавить</button>
                </div>
            </div>
        </div>
        <table class="table table-striped">
            <thead>
                <tr>
                    <th>Предмет</th>
                    <th>Цена</th>
                    <th>Куплено</th>
                </tr>
            </thead>
            <tbody>
                <tr *ngFor="let item of items">
                    <td>{{item.purchase}}</td>
                    <td>{{item.price}}</td>
                    <td><input type="checkbox" [(ngModel)]="item.done" /></td>
                </tr>
            </tbody>
        </table>
    </div>`
    })
  .Class({
    constructor: function() { 
     
        this.items= [
            new Item("Хлеб",15.9),
            new Item("Масло",60),
            new Item("Картофель",22.6, true),
            new Item("Сыр",310)
        ];
    }
});
 
AppComponent.prototype.addItem = function (text, price) {
        if (text == undefined || text.trim() == "" || price == undefined)
            return;
        this.items.push(new Item(text, price));
};
Здесь определен главный компонент приложения - AppComponent. Для его создания применяется функция ng.core.Component() из библиотеки angular/core

Весь код почти аналогичен коду компонента на TypeScript из прошлой темы.

Также добавим в папку app новый файл app.module.js:


var AppModule = ng.core.NgModule({
    imports: [ng.platformBrowser.BrowserModule, ng.forms.FormsModule],
    declarations: [AppComponent],
    bootstrap: [AppComponent]
  })
  .Class({
    constructor: function() { }
});
Модуль создается с помощью функции ng.core.NgModule(), которая определена в библиотеке angular/core.

Свойство imports у модуля указывает на модули, которые будут использоваться. Свойство declarations хранит набор используемых компонентов, а свойство bootstrap определяет загружаемый компонент - AppComponent.

И далее создадим в папке app новый файл main.js:


ng.platformBrowserDynamic.platformBrowserDynamic()
    .bootstrapModule(AppModule);
Этот файл будет загружать основной модуль приложения.

И определим в корневой папке проекта веб-страницу приложения index.html:



<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Приложение покупок</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
    <script src="https://unpkg.com/core-js/client/shim.min.js"></script>
    <script src="https://unpkg.com/zone.js/dist/zone.min.js"></script>
    <script src="https://unpkg.com/rxjs/bundles/Rx.min.js"></script>
  
    <script src="https://unpkg.com/@angular/core@2.0.0/bundles/core.umd.js"></script>
    <script src="https://unpkg.com/@angular/common@2.0.0/bundles/common.umd.js"></script>
    <script src="https://unpkg.com/@angular/compiler@2.0.0/bundles/compiler.umd.js"></script>
    <script src="https://unpkg.com/@angular/forms@2.0.0/bundles/forms.umd.js"></script>
    <script src="https://unpkg.com/@angular/platform-browser@2.0.0/bundles/platform-browser.umd.js"></script>
    <script src="https://unpkg.com/@angular/platform-browser-dynamic@2.0.0/bundles/platform-browser-dynamic.umd.js"></script>
  </head>
  <body>
  
    <my-app>Загрузка...</my-app>
    <script src="app/app.component.js"></script>
    <script src="app/app.module.js"></script>
    <script src="app/main.js"></script>
  </body>
</html>
Для подключения внешних файлов здесь применяется CDN unpkg.com.

Первая группа файлов аналогична тем, что подключались в прошлой теме в приложении на TypeScript:

<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
<script src="https://unpkg.com/core-js/client/shim.min.js"></script>
<script src="https://unpkg.com/zone.js/dist/zone.min.js"></script>
<script src="https://unpkg.com/rxjs/bundles/Rx.min.js"></script>
Но кроме этих файлов также необходимо подключить все используемые модули. Можно заметить, что в коде используются функции, которые начинаются с ng.*, например, ng.core.Component, ng.forms.FormsModule и другие. Это тот функционал, который предоставляется непосредственно библиотеками Angular, и эти библиотеки надо подключить:

<script src="https://unpkg.com/@angular/core@2.0.0/bundles/core.umd.js"></script>
<script src="https://unpkg.com/@angular/common@2.0.0/bundles/common.umd.js"></script>
<script src="https://unpkg.com/@angular/compiler@2.0.0/bundles/compiler.umd.js"></script>
<script src="https://unpkg.com/@angular/forms@2.0.0/bundles/forms.umd.js"></script>
<script src="https://unpkg.com/@angular/platform-browser@2.0.0/bundles/platform-browser.umd.js"></script>
<script src="https://unpkg.com/@angular/platform-browser-dynamic@2.0.0/bundles/platform-browser-dynamic.umd.js"></script>
В итоге у нас получится следующая структура проекта:

app

app.component.js

app.module.js

main.js

index.html

Теперь запустим проект. Для этого достаточно перенести файл веб-страницы в браузер:

Первое приложение на Angular 2 на JavaScript

 

====================Основы Angular========================
==========================================================
.....................Компоненты...........................
     
Одним из ключевых элементов приложения являются компоненты. Компонент управляет отображением представления на экране.

Так, при создании первого приложения в прошлой главе был определен следующий компонент
 (in app.component.ts)


import { Component } from '@angular/core';
     
@Component({
    selector: 'my-app',
    template: `<label>Введите имя:</label>
                 <input [(ngModel)]="name" placeholder="name">
                 <h1>Добро пожаловать {{name}}!</h1>`
})
export class AppComponent { 
    name: "";
}
Сам класс компонента здесь относительно небольшой:


export class AppComponent { 
    name: "";
}
Чтобы класс мог использоваться в других модулях, он определяется с ключевым словом export. 
В самом же классе определена лишь одна переменная, которая в качестве значения 
хранит некоторую строку.

Для создания компонента необходимо импортировать функцию декоратора @Component 
из библиотеки @angular/core. Декоратор @Component позволяет 
идентифицировать класс как компонент.

Если бы мы не применили декоратор @Component к классу AppComponent, то класс AppComponent компонентом бы не считался.

Декоратор @Component в качестве параметра принимает объект с конфигурацией, которая указывает фреймворку, как работать с компонентом и его представлением.

С помощью свойства #template#. Шаблон представляет кусок разметки HTML с вкраплениями кода Angular. Фактически шаблон это и есть представление, которое увидит пользователь при работе с приложением.

Каждый компонент должен иметь один шаблон. Однако необязательно определять шаблон напрямую с помощью свойства template. Можно вынести шаблон во внешний файл с разметкой html, а для его подключения использовать свойство templateUrl.

Шаблон может быть однострочным или многострочным. Если шаблон многострочный, то он заключается в косые кавычки (`), которые стоит отличать от стандартных ординарных кавычек (').

Также в примере выше устанавливается свойство selector, которое определяет селектор CSS. В элемент с этим селектором Angular будет добавлять представление компонента. Например, в примере выше селектор имеет значение my-app. Соответственно если html-страница содержит элемент <my-app></my-app>, например:


<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Hello Angular 5</title>
</head>
<body>
    <my-app>Загрузка...</my-app>
    <script src="public/polyfills.js"></script>
    <script src="public/app.js"></script>
</body>
</html>
То именно этот элемент будет использоваться для рендеринга представления компонента.

============================================================================================
....................................Модули..................................................
============================================================================================

Приложение Angular состоит из отдельных модулей. Как правило, приложения состоят из нескольких модулей. И каждое приложение Angular как минимум имеет один корневой модуль (root module), который, согласно условностям, называется AppModule. Например, в первой главе использовался следующий корневой модуль:


import { NgModule }      from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { FormsModule }   from '@angular/forms';
import { AppComponent }   from './app.component';
 
@NgModule({
    imports:      [ BrowserModule, FormsModule ],
    declarations: [ AppComponent ],
    bootstrap:    [ AppComponent ]
})
export class AppModule { }

Для работы модуля ему необходимы ряд библиотек, поэтому в начале файла идет их подключение. Имя каждой библиотеки Angular начинается с префикса @angular.

Библиотеки устанавливаются через пакетный менеджер npm и импортируются с помощью директивы import. Например, импорт функциональности декоратора NgModule из библиотеки @angular/core:

1
import { NgModule } from '@angular/core';
То есть здесь мы должны импортировать все модули и классы, которые использует данный модуль. В частности, для AppModule необходимы:

NgModule: функциональность декоратора NgModule, без которой мы не сможем создать модуль

BrowserModule: модуль, необходимый для работы с браузером

FormsModule: модуль, необходимый для работы с формами html и, в частности, с элементами input. (Так как класс компонента работает с подобными элементами, то мы обязаны также импортировать этот модуль)

AppComponent: функциональность корневого компонента приложения

Непосредственно сам модуль представлен классом AppModule, который на первый взгляд ничего не делает и не содержит никакого функционала:

1
export class AppModule { }
Однако в Angular модуль это не просто класс. Каждый модуль должен определяться с декоратором @NgModule.

NgModule представляет функцию-декоратора, которая принимает объект, свойства которого описывают метаданные модуля. Наиболее важные свойства:

declarations: классы представлений (view classes), которые принадлежат модулю. Angular имеет три типа классов представлений: компоненты (components), директивы (directives), каналы (pipes)

exports: набор классов представлений, которые должны использоваться в шаблонах компонентов из других модулей

imports: другие модули, классы которых необходимы для шаблонов компонентов из текущего модуля

providers: классы, создающие сервисы, используемые модулем

bootstrap: корневой компонент, который вызывается по умолчанию при загрузке приложения

В случае выше единственным классом представлений является компонент AppComponent. Поэтому он указывается для свойств declarations и bootstrap. И поскольку его действие зависит от модулей BrowserModule и FormsModule, то данные модули указываются для свойства imports.

Но при необходимости мы могли бы использовать и другие свойства:


@NgModule({
    imports:      [ BrowserModule, FormsModule ],
    declarations: [ AppComponent ],
    bootstrap:    [ AppComponent ],
    exports:      [ ],
    providers:    [ ]
})

 
====================================================================
====================================================================
.........................Загрузка приложения........................


При запуске приложения первым выполняется код, который определен в файле main.ts. Этот файл имеет следующее содержимое:


import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
import { AppModule } from './app/app.module';
const platform = platformBrowserDynamic();
platform.bootstrapModule(AppModule);
Первая строка импортирует функциональность модуля platformBrowserDynamic из пакета angular/platform-browser-dynamic. platformBrowserDynamic использует bootstrapModule для загрузки нужного модуля.

То есть фактически здесь platformBrowserDynamic запускает импортированный во второй строке модуль AppModule. После этого начинает работать вся логика, которая заложена в модуле AppModule, который представляет главный модуль приложения. Больше ничего файл main.ts не делает.

main.ts и AppModule и AppComponent в Angular
В самом же AppModule нам надо указать, какой именно компонент будет использоваться в качестве основного при загрузке. Для этого используется параметр bootstrap декоратора NgModule:


import { NgModule }      from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { FormsModule }   from '@angular/forms';
import { AppComponent }   from './app.component';
 
@NgModule({
    imports:      [ BrowserModule, FormsModule ],
    declarations: [ AppComponent ],
    bootstrap:    [ AppComponent ]
})
export class AppModule { }
То есть в данном случае значение bootstrap: [ AppComponent ] указывает, что модуль для загрузки в качестве основного компонента будет использовать класс AppComponent.

Если мы опустим компонент: bootstrap: [ ] или вовсе уберем параметр bootstrap, то на веб-страницу не будет загружаться представление из комопонента AppComponent.


 =======================================================================
 =======================================================================
 =======================================================================
 ......................Стили и шаблоны компонента.......................

========================================================================
 
  
Стилизация компонента может производиться как с помощью установки стилей в самом компоненте, так и с помощью подключения внешних css-файлов.

Для установки стилей в директиве @Component определено свойство styles:


import { Component } from '@angular/core';
 
@Component({
    selector: 'my-app',
    template: `<h1>Hello Angular 2</h1>
            <p>Angular 2 представляет модульную архитектуру приложения</p>`,
    styles: [` 
            h1, h2{color:navy;}
            p{font-size:13px; font-family:Verdana;}
    `]
})
export class AppComponent { }

Параметр styles содержит набор стилей, которые будут использоваться компонентом:

Стили в компонентах в Angular 2
При использовании стилей следует учитывать, что они применяются локально только к разметке, управляемой компонентом. Например, если на странице будут элементы вне области управления компонентом, то к ним уже не будут применяться стили. Например:


<body>
    <my-app>Loading...</my-app>
    <h2>Подзаголовок</h2>
</body>
Если бы заголовок h2 здесь располагался бы в шаблоне компонента, то к нему применялся бы стиль. А так он не будет стилизован:

Стилизация в Angular 2
Селектор :host
Селектор :host ссылается на элемент, в котором хостится компонент. То есть в данном случае это элемент <my-app></my-app>. И селектор :host как раз позволяет применить стили к этому элементу:


styles: [` 
    h1, h2{color:navy;}
    p{font-size:13px;}
    :host {
        font-family: Verdana;
        color: #555;
    }
`]
Подключение внешних файлов
Если стилей много, то код компонента может быть слишком раздут, и в этом случае их лучше вынести в отдельный файл css. Так, создадим в одной папке с классом компонента (который по умолчанию располагается в папке app) новый файл app.component.css со следующим содержимым:


h1, h2{color:navy;}
p{font-size:13px;}
:host {
    font-family: Verdana;
    color: #555;
}
Затем изменим код компонента:


import { Component } from '@angular/core';
 
@Component({
    selector: 'my-app',
    template: `<h1>Hello Angular 2</h1>
            <p>Angular 5 представляет модульную архитектуру приложения</p>`,
    styleUrls: ['./app.component.css']
})
export class AppComponent { }

Параметр styleUrls позволяет указать набор файлов css, которые применяются для стилизации. В данном случае предполагается, что файл css располагается в проекте в папке app.

Похожим образом мы можем вынести шаблон в отдельный файл html. Также в папке app создадим новый файл app.component.html со следующим кодом:


<h1>Hello Angular 2</h1>
<p>Angular 2 представляет модульную архитектуру приложения</p>
То есть здесь определен весь тот же код, что ранее был в шаблоне компонента. И теперь изменим сам компонент:

==
import { Component } from '@angular/core';
 
@Component({
    selector: 'my-app',
    templateUrl: './app.component.html',
    styleUrls: ['./app.component.css']
})
export class AppComponent { }

За счет выноса кода css и html код самого компонента стал чище и проще. Однако если мы производим сборку приложения через webpack, то мы можем столкнуться с проблемами. Нам надо указать сборщику, как загружать эти файлы html и css. И для этого можно воспользоваться загрузчиками html-loader и raw-loader.

В частности, в начале необходимо загрузить пакеты загрузчиков в проект через npm. Для этого можно определить в файле package.json следующие пакеты:



{
    "name": "helloapp",
    "version": "1.0.0",
    "description": "First Angular 5 Project",
    "author": "Eugene Popov <metanit.com>",
    "scripts": {
        "dev": "webpack-dev-server --hot --open",
        "build": "webpack"
    },
    "dependencies": {
    "@angular/common": "~6.0.0",
    "@angular/compiler": "~6.0.0",
    "@angular/core": "~6.0.0",
    "@angular/forms": "~6.0.0",
    "@angular/platform-browser": "~6.0.0",
    "@angular/platform-browser-dynamic": "~6.0.0",
    "@angular/router": "~6.0.0",
    "core-js": "^2.5.5",
    "rxjs":"^6.1.0",
    "zone.js": "^0.8.26"
  },
  "devDependencies": {
    "@types/node":"^10.0.4",
    "typescript": "^2.8.3",
    "webpack": "^4.7.0",
    "webpack-cli": "^2.1.2",
    "webpack-dev-server": "^3.1.4",
    "angular2-template-loader": "^0.6.2",
    "awesome-typescript-loader": "^5.0.0",
    "uglifyjs-webpack-plugin": "^1.2.5",
    "raw-loader": "^0.5.1",
    "html-loader":"^0.5.1"
  }
}
И после этого загрузить пакеты командой npm install.

И затем загрузчики raw-loader и html-loader надо применить в конфигурации webpack:



var path = require('path');
var webpack = require('webpack');
var UglifyJSPlugin = require('uglifyjs-webpack-plugin'); // плагин минимизации
module.exports = {
    entry: {
        'polyfills': './src/polyfills.ts',
        'app': './src/main.ts'
      },
   output:{
       path: path.resolve(__dirname, './public'),     // путь к каталогу выходных файлов - папка public
       publicPath: '/public/',
       filename: "[name].js"       // название создаваемого файла
   },
   resolve: {
    extensions: ['.ts', '.js']
  },
   module:{
       rules:[   //загрузчик для ts
           {
               test: /\.ts$/, // определяем тип файлов
               use: [
                {
                    loader: 'awesome-typescript-loader',
                    options: { configFileName: path.resolve(__dirname, 'tsconfig.json') }
                  } ,
                   'angular2-template-loader'
               ]
            },{
              test: /\.html$/,
              loader: 'html-loader'
            }, {
                test: /\.css$/,
                include: path.resolve(__dirname,'src/app'),
                loader: 'raw-loader'
              }
       ]
   },
   plugins: [
    new webpack.ContextReplacementPlugin(
        /angular(\\|\/)core/,
        path.resolve(__dirname, 'src'), // каталог с исходными файлами
      {} // карта маршрутов
    ),
    new UglifyJSPlugin()
  ]
}

==========================================================================================
==========================================================================================
..................................Привязка...............................................
=========================================================================================

    

 
Angular поддерживает механизм привязки, благодаря которому различные части шаблона могут быть привязаны к некоторым значениям, определенным в компоненте.

В Angular есть четыре формы привязки данных:

Привязка элемента DOM к значению компонента (односторонняя). В двойных фигурных скобках указывается выражение, к которому идет привязка: {{выражение}}. Например:

1
<h1>Добро пожаловать {{name}}!</h1>
Привязка свойства элемента html к значению компонента (односторонняя). Например:

2
<input type="text" [value]="name" />
Привязка метода компонента к событию в DOM (генерация события в DOM вызывает метод на компоненте)(односторонняя). Например:

3
<button (click)="addItem(text, price)">Добавить</button>
Двусторонняя привязка, когда элемент DOM привязан к значению на компоненте, при этом изменения на одном конце привязки сразу приводят к изменениям на другом конце. Например:

4
<input [(ngModel)]="name" placeholder="name">
Первый вид привязки заключается в использовании фигурных скобок, в которые передается значение из компонента. Например, пусть у нас будет определен следующий компонент:


import { Component } from '@angular/core';
      
@Component({
    selector: 'my-app',
    template: `<p>Имя: {{name}}</p>
                <p>Возраст: {{age}}</p>`
})
export class AppComponent { 
    name = "Tom";
    age = 25;
}
И при запуске приложения выражения типа {{name}} будут автоматически заменяться соответствующими значениями, определенными в компоненте:

Data Binding in Angular 2
И если в процессе работы приложения свойства name и age в компоненте изменят свое значение, то также изменится значение в разметке html, которая привязана к этим свойствам.

Привязка свойств элементов html
Мы можем привязать значение к свойству элемента html. В этом случае свойство указывается в квадратных скобках:


import { Component } from '@angular/core';
      
@Component({
    selector: 'my-app',
    template: `<input type="text" [value]="name" />`
})
export class AppComponent { 
    name = "Tom";
}
Хотя в данном случае мы могли бы написать и так:

1
template: `<input type="text" value="{{name}}" />`
Но важно понимать, что здесь идет привязка не к атрибуту, а именно к свойству элемента в javascript, который представляет данный элемент html. Например, мы могли бы привязать некоторое значение к текстовому содержимому элемента:

1
template: `<p [textContent]="name"></p>`
У html-элемента <p> нет атрибута textContent. Зато у интерфейса Node, который представляет данный элемент DOM, есть свойство textContent, к которому мы можем осуществить привязку.

Привязка к событию
Привязка к событию позволяет связать с событием элемента метод из компонента:


import { Component } from '@angular/core';
      
@Component({
    selector: 'my-app',
    template: `<p>Количество кликов {{count}}</p>
                <button (click)="increase()">Click</button>`
})
export class AppComponent { 
    count: number=0;
    increase() : void {
        this.count++;
    }
}
В шаблоне определен элемент button, у которого есть событие click. Для обработки этого события в классе AppComponent определен метод increase(), который увеличивает количество условных кликов. В итоге при нажатии на кнопку сработает данный метод:

Event Binding in Angular 2
В качестве альтернативы мы могли бы установить привязку к событию так:


template: `<p>Количество кликов {{count}}</p>
                <button on-click="increase()">Click</button>`
После префикса on через дефис идет название события.

Мы также можем передавать информацию о событии через объект $event:


import { Component } from '@angular/core';
       
@Component({
    selector: 'my-app',
    template: `<p>Количество кликов {{count}}</p>
                <button (click)="increase($event)">Click</button>`
})
export class AppComponent { 
    count: number=0;
    increase($event) : void {
        this.count++;
        console.log($event);
    }
}
$event - это встроенный объект, через который Angular передает информацию о событии.

Двусторонняя привязка
Двусторонняя привязка позволяет динамически менять значения на одном конце привязки при изменениях на другом конце. Как правило, двусторонняя привязка применяется при работе с элементами ввода, например, элементами типа input. Например:

import { Component } from '@angular/core';
      
@Component({
    selector: 'my-app',
    template: `<p>Привет {{name}}</p>
                <input type="text" [(ngModel)]="name" /> <br><br>
                <input type="text" [(ngModel)]="name" />`
})
export class AppComponent { 
    name:string="Tom";
}
Здесь к свойству name класса AppComponent привязаны сразу три элемента: параграф и два текстового поля. Тектовые поля связаны со свойством name двусторонней привязкой. Для ее создания применяется выражение [(ngModel)]="выражение".

В итоге изменения в текстовом поле будут сказываться на тексте во втором текстовом поле и параграфе.

=========================================================================
=========================================================================
.................Работа с компонентами....................................
=========================================================================


Кроме основных компонентов в приложении мы также можем определять какие-то вспомогательные компоненты, которые управляют каким-то участком разметки html. Более того в приложении на странице может быть ряд разных блоков с какой-то определенной задачей. И для каждого такого блока можно создать отдельный компонент, чтобы упростить управление блоками на странице.

Добавим в проект второй компонент. Для этого добавим в папку src/app новый файл child.component.ts. 
Взаимодействие между компонентами в Angular
Определим в файле child.component.ts следующий код:


import { Component } from '@angular/core';
      
@Component({
    selector: 'child-comp',
    template: `<h2>Добро пожаловать {{name}}!</h2>`,
    styles: [`h2, p {color:red;}`]
})
export class ChildComponent { 
    name= "Евгений";
}

Здесь определен класс ChildComponent. Опять же чтобы сделать этот класс компонентом, необходимо применить декоратор @Component.

Компонент будет управлять разметкой html, которая будет вставляться в элемент child-comp.

Шаблон представления будет просто выводить заголовок. В заголовке выводится имя, заданное через переменную name.

И кроме того, здесь определены стили для элементов h2 и p.

Теперь изменим код компонента AppComponent в файле app.component.ts:


import { Component } from '@angular/core';
      
@Component({
    selector: 'my-app',
    template: `<child-comp></child-comp>
                <p>Привет {{name}}</p>`,
    styles: [`h2, p {color:#333;}`]
})
export class AppComponent { 
    name = 'Петр';
}

Это основной компонент, который будет запускаться при запуске приложения, и через него мы будем использовать остальные компоненты. Так, компонент ChildComponent будет загружаться в элемент child-comp. И в шаблоне компонента AppComponent как раз определен такой элемент.

Кроме того, компонент определяет стили для тех же элементов на странице, и также, как и ChildComponent, определяет свойство name, только с другим значением.

Чтобы использовать все определенные в проекте компоненты, они должны быть указаны в главном модуле приложения. Определим в файле app.module.ts следующий модуль:


import { NgModule }      from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { FormsModule }   from '@angular/forms';
import { AppComponent }   from './app.component';
import { ChildComponent }   from './child.component';
@NgModule({
    imports:      [ BrowserModule, FormsModule ],
    declarations: [ AppComponent, ChildComponent ],
    bootstrap:    [ AppComponent ]
})
export class AppModule { }

Запустим проект

Работа с компонентами в Angular 5
Результат показывает, что несмотря на то, что один компонент как бы включен в другой с помощью тега <child-comp>, но тем не менее стили одного компонента не применяются к другому. Каждый компонент очерчивает свою область с помощью шаблона, свое представление, которым он и управляет.

Также каждый компонент использует свое значение свойства name. То есть компоненты фактически существуют относительно независимо.

Даже если мы уберем из ChildComponent определение свойства name:


import { Component } from '@angular/core';
      
@Component({
    selector: 'child-comp',
    template: `<h2>Добро пожаловать {{name}}!</h2>`,
    styles: [`h2, p {color:red;}`]
})
export class ChildComponent { }
То родительский или главный компонент, все равно не окажет влияния на ChildComponent:

Множество компонентов в Angular 2
Хотя может показаться, что ChildComponent для выражения {{name}} в своем шаблоне должен использовать свойство name из родительского компонента AppComponent. Но это не так. Компоненты относительно независимы друг от друга.

ng-content
Элемент ng-content позволяет внедрять родительским компонентам код html в дочерние компоненты. Так, изменим компонент ChildComponent следующим образом:


import { Component } from '@angular/core';
      
@Component({
    selector: 'child-comp',
    template: `<ng-content></ng-content>
                <p>Привет {{name}}</p>`,
    styles: [`h2, p {color:navy;}`]
})
export class ChildComponent { 
    name= "Евгений";
}
Вместо элемента <ng-content> извне можно будет передать любое содержимое.

И изменим код главного компонента AppComponent:


import { Component } from '@angular/core';
      
@Component({
    selector: 'my-app',
    template: `<child-comp><h2>Добро пожаловать {{name}}!</h2></child-comp>`,
    styles: [`h2, p {color:#333;}`]
})
export class AppComponent { 
    name = 'Tom';
}
В элемент <child-comp> здесь передается заголовок <h2>Добро пожаловать {{name}}!</h2>. Затем этот заголовок будет вставляться в дочерний компонент ChildComponent на место <ng-content>:

ng-content в Angular 2
Причем управлять разметкой, которая вставляется в <ng-content>, будет управлять AppComponent. Поэтому именно этот компонент задает стили и выражения привязки для вставляемого куска html.
===========================================================================================
===========================================================================================
..........................Взаимодействие между компонентами................................
===========================================================================================

    

 
В прошлой теме было рассмотрено, как вызывать компонент из главного компонента. Однако по умолчанию эти компоненты никак не взаимодействуют, они независимы. Каждый компонент определяет свои выражения привязки. Однако что, если мы хотим свойства дочернего компонента привязать к свойствам из главного компонента? Для этого определим следующий дочерний компонент:


import { Input, Component} from '@angular/core';
      
@Component({
    selector: 'child-comp',
    template: `<p>Имя пользователя: {{userName}}</p>
              <p>Возраст пользователя: {{userAge}}</p>`
})
export class ChildComponent{ 
    @Input() userName: string;
    @Input() userAge: number;
}
Ключевым моментом здесь является определение входных свойств с помощью декоратора @Input(). И естественно чтобы использовать декоратор, его надо импортировать:

1
import { Input} from '@angular/core';
Ключевой особенностью таких входных свойств является то, что они могут устанавливаться извне, например, из главного компонента.

Теперь изменим код главного компонента:


import { Component } from '@angular/core';
      
@Component({
    selector: 'my-app',
    template: `<child-comp [userName]="name" [userAge]="age"></child-comp>
                <input type="text" [(ngModel)]="name" />`
})
export class AppComponent { 
    name:string="Tom";
    age:number = 24;
}
Поскольку свойство userName в дочернем компоненте определено как входное с декоратором Input, то в главном компоненте мы можем его использовать как атрибут и фактически применить привязку свойств:

1
<child-comp [userName]="name" [userAge]="age"></child-comp>
То же самое касается и свойства userAge.

В итоге свойства userAge и userName будут привязаны к значениям из главного компонента:

Взаимодействие компонентов в Angular 2
Привязка к сеттеру
Кроме привязки к свойству мы можем установить привязку к сеттеру дочернего компонента. (Подробнее про сеттеры и вообще про модификаторы доступа можно посмотреть здесь). Это может быть необходимо, когда в дочернем компоненте надо осуществлять проверку или даже модификацию значения, получаемого от главного компонента.

Например, пусть в главном компоненте устанавливается возраст пользователя:


import { Component } from '@angular/core';
       
@Component({
    selector: 'my-app',
    template: `<child-comp [userName]="name" [userAge]="age"></child-comp>
                <input type="number" [(ngModel)]="age" />`
})
export class AppComponent { 
    name:string="Tom";
    age:number = 24;
}
А в дочернем компоненте будем получать переданный возраст через сеттер:


import { Input, Component} from '@angular/core';
       
@Component({
    selector: 'child-comp',
    template: `<p>Имя пользователя: {{userName}}</p>
              <p>Возраст пользователя: {{userAge}}</p>`
})
export class ChildComponent{ 
    @Input() userName: string;
     _userAge: number;
      
    @Input()
    set userAge(age:number) {
        if(age<0)
            this._userAge=0;
        else if(age>100)
            this._userAge=100;
        else
            this._userAge = age;
  }
  get userAge() { return this._userAge; }
}
В главном компоненте мы можем ввести любое значение в поле ввода, в том числе и отрицательные числа. В дочернем компоненте через сеттер проверяем введенное значение и при необходимости корректируем его.
==================================================================
==================================================================
==================================================================
.............Привязка к событиям дочернего компонента..............
...................................................................



 
Еще одной формой взаимодействия представляет привязка к событиям дочернего компонента. Так, определим следующий дочерний компонент:


import { Component, EventEmitter, Input, Output} from '@angular/core';
       
@Component({
    selector: 'child-comp',
    template: `<button (click)="change(true)">+</button>
               <button (click)="change(false)">-</button>`
})
export class ChildComponent{ 
     
    @Output() onChanged = new EventEmitter<boolean>();
    change(increased:any) {
        this.onChanged.emit(increased);
    }
}
В этом компоненте у кнопки используется событие click, которое вызывает метод change, передавая ему значение true или false. Здесь же в дочернем компоненте мы можем и обработать события. Но если мы должны передавать его родительскому компоненту, то для этого нам надо использовать свойство типа EventEmitter, коим здесь является свойство onChanged. Поскольку мы будем передавать значение типа true или false, то данное свойство типизируется типом boolean. При этом свойство onChanged должно быть выходным, поэтому оно помечается с помощью декоратора @Output.

Фактически свойство onChanged будет представлять собой событие, которое вызывается в методе change() по клику на кнопку и передается главному компоненту.

Далее определим код главного компонента:


import { Component } from '@angular/core';
       
@Component({
    selector: 'my-app',
    template: `<h2>Количество кликов: {{clicks}}</h2>
              <child-comp (onChanged)="onChanged($event)"></child-comp>`
})
export class AppComponent { 
     
    clicks:number = 0;
    onChanged(increased:any){
        increased==true?this.clicks++:this.clicks--;
    }
}
С помощью выражения (onChanged)="onChanged($event)" привязываем метод onChanged к событию onChanged(), вызываемое в дочернем компоненте. Параметр $event инкапсулирует все данные, которые передаются из дочернего компонента.

В итоге при нажатии на кнопки в дочернем компоненте событие нажатия будет транслироваться главному копоненту, который будет в зависимости от переданного значения увеличивать или уменьшать счетчик.

Передача событий между компонентами в Angular 2
Двусторонняя привязка
В примере выше мы определяли привязку к событию дочернего компонента: при возникновении события в дочернем компоненте мы обрабатывали это событие в главном компоненте с помощью метода. Но мы также можем использовать двустороннюю привязку между свойствами главного и дочернего компонента. Например, пусть дочерний компонент будет выглядеть следующим образом:


import { Component, Input, Output, EventEmitter } from '@angular/core';
       
@Component({
    selector: 'child-comp',
    template: `<input [ngModel]="userName" (ngModelChange)="onNameChange($event)" />`
})
export class ChildComponent{ 
     
    @Input() userName:string;
    @Output() userNameChange = new EventEmitter<string>();
    onNameChange(model: string){
         
        this.userName = model;
        this.userNameChange.emit(model);
    }
}
Здесь определено входное свойство userName, к которому привязано текстовое поле input. Для связи используется атрибут [ngModel], который связывает значение атрибута value у текстового поля со свойством userName.

Для отслеживания изменения модели этого поля с помощью атрибута (ngModelChange) привязываем метод, который срабатывает при изменении значения. То есть ngModelChange - это фактически событие изменения введенного значения, поэтому здесь действует привязка к событию.

Так как у нас здесь односторонняя привязка, то в методе-обработчике получаем введенное значение и изменяем свойство userName и генерируем событие userNameChange, которое определено как выходной параметр.

То есть здесь извне мы получаем значение для свойства userName и устанавливаем его для текстового поля. При вводе пользователя в это поле генерируем во вне событие userNameChange.

Теперь определим код главного компонента:


import { Component} from '@angular/core';
       
@Component({
    selector: 'my-app',
    template: `<child-comp [(userName)]="name"></child-comp>// я код добавила в отдельный 
    файл child.component.html
                <div>Выбранное имя: {{name}}</div>`
})
export class AppComponent { 
 
    name: string = "Tom";
}
Здесь устанавливается двусторонняя привязка свойств userName дочернего компонента и свойства name главного компонента. При этом не надо уже вручную обрабатывать событиe userNameChange, все будет делаться автоматически.

==================================================================================
==================================================================================
==================================================================================
......................Жизненный цикл компонента....................................
...................................................................................


    

 
После создания компонента фреймворк Angular вызывает у этого компонента ряд методов, которые представляют различные этапы жизненного цикла:

Жизненный цикл компонентов в Angular 5
-ngOnChanges: вызывается до метода ngOnInit() при начальной установке свойств, которые связаны механизмом привязки, а также при любой их переустановке или изменении их значений. Данный метод в качестве параметра принимает объект класса SimpleChanges, который содержит предыдущие и текущие значения свойства.

-ngOnInit: вызывается один раз после установки свойств компонента, которые участвуют в привязке. Выполняет инициализацию компонента

-ngDoCheck: вызывается при каждой проверке изменений свойств компонента сразу после методов ngOnChanges и ngOnInit

-ngAfterContentInit: вызывается один раз после метода ngDoCheck() после вставки содержимого в представление компонента кода html

-ngAfterContentChecked: вызывается фреймворком Angular при проверке изменений содержимого, которое добавляется в представление компонента. Вызывается после метода ngAfterContentInit()  и после каждого последующего вызова метода ngDoCheck().

-ngAfterViewInit: вызывается фреймворком Angular после инициализации представления компонента, а также представлений дочерних компонентов. Вызывается только один раз сразу после первого вызова метода ngAfterContentChecked()

-ngAfterViewChecked: вызывается фреймворком Angular после проверки на изменения в представлении компонента, а также проверки представлений дочерних компонентов. Вызывается после первого вызова метода ngAfterViewInit() и после каждого последующего вызова ngAfterContentChecked()

-ngOnDestroy: вызывается перед тем, как фреймворк Angular удалит компонент.

Каждый такой метод определен в отдельном интерфейсе, который называется по имени метода без префикса "ng". Например, метод ngOnInit определен в интерфейсе OnInit. Поэтому, если мы хотим отслеживать какие-то этапы жизненного цикла компонента, то класс компонента должен применять соответствующие интерфейсы:


import { Component, OnInit, OnDestroy } from '@angular/core';
      
@Component({
    selector: 'my-app',
    template: `<p>Hello Angular 2</p>`
})
export class AppComponent implements OnInit, OnDestroy { 
    name:string="Tom";
     
    constructor(){ this.log(`constructor`); }
    ngOnInit() { this.log(`onInit`); }
 
    ngOnDestroy() { this.log(`onDestroy`); }
 
    private log(msg: string) {
        console.log(msg);
    }
}
ngOnInit
Метод ngOnInit() применяется для какой-то комплексной инициализации компонента. Здесь можно выполнять загрузку данных с сервера или из других источников данных.

ngOnInit() не аналогичен конструктору. Конструктор также может выполнять некоторую инициализацию объекта, в то же время что-то сложное в конструкторе делать не рекомендуется. Конструктор должен быть по возможности простым и выполнять самую базовую инициализацию. Что-то более сложное, например, загрузку данных с сервера, которая может занять продолжительное время, лучше делать в методе ngOnInit.

ngOnDestroy
Метод ngOnDestroy() вызывается перед удалением компонента. И в этом методе можно освобождать те используемые ресурсы, которые не удаляются автоматически сборщиком мусора. Здесь также можно удалять подписку на какие-то события элементов DOM, останавливать таймеры и т.д.

ngOnChanges
Метод ngOnChanges() вызывается перед методом ngOnInit() и при изменении свойств в привязке. С помощью параметра SimpleChanges в методе можно получить текущее и предыдущее значение измененного свойства. Например, пусть у нас будет следующий дочерний компонент:



import { Component, Input, OnInit, OnChanges, SimpleChanges } from '@angular/core';
      
@Component({
    selector: 'child-comp',
    template: `<p>Привет {{name}}</p>`
})
export class ChildComponent implements OnInit, OnChanges { 
    @Input() name: string;
 
    constructor(){ this.log(`constructor`); }
    ngOnInit() { this.log(`onInit`); }
     
    ngOnChanges(changes: SimpleChanges) {
      for (let propName in changes) {
        let chng = changes[propName];
        let cur  = JSON.stringify(chng.currentValue);
        let prev = JSON.stringify(chng.previousValue);
        this.log(`${propName}: currentValue = ${cur}, previousValue = ${prev}`);
      }
    }
    private log(msg: string) {
        console.log(msg);
    }
}
И пусть этот компонент используется в главном компоненте:



import { Component, OnChanges, SimpleChanges} from '@angular/core';
      
@Component({
    selector: 'my-app',
    template: `<child-comp [name]="name"></child-comp>
                <input type="text" [(ngModel)]="name" />
                <input type="number" [(ngModel)]="age" />`
})
export class AppComponent implements OnChanges { 
    name:string="Tom";
    age:number = 25;
    ngOnChanges(changes: SimpleChanges) {
      for (let propName in changes) {
        let chng = changes[propName];
        let cur  = JSON.stringify(chng.currentValue);
        let prev = JSON.stringify(chng.previousValue);
        this.log(`${propName}: currentValue = ${cur}, previousValue = ${prev}`);
      }
    }
 
    private log(msg: string) {
        console.log(msg);
    }
}
То есть значение для свойства name передается в дочерний компонент ChildComponent из главного - AppComponent. Причем в главном компоненте тоже реализован метод ngOnChanges().

И если мы запустим приложение, то сможем заметить, что при каждом изменении свойства name в главном компоненте вызывается метод ngOnChanges:

OnChanges в Angular 2
В то же время надо отметить, что данный метод вызывается только при изменении входных свойств с декоратором @Input. Поэтому изменение свойства age в AppComponent здесь не будет отслеживаться.

Реализация всех методов
Определим следующий дочерний компонент:

import { Component, 
         Input, 
         OnInit,
         DoCheck,
         OnChanges,
        AfterContentInit, 
        AfterContentChecked, 
        AfterViewChecked, 
        AfterViewInit} from '@angular/core';
      
@Component({
    selector: 'child-comp',
    template: `<p>Привет {{name}}</p>`
})
export class ChildComponent implements OnInit,
         DoCheck,
         OnChanges,
        AfterContentInit, 
        AfterContentChecked, 
        AfterViewChecked, 
        AfterViewInit  { 
    @Input() name: string;
    count:number=1;
     
    ngOnInit() {
       
      this.log(`ngOnInit`);
    }
    ngOnChanges() {
       
      this.log(`OnChanges`);
    }
    ngDoCheck() {
       
      this.log(`ngDoCheck`);
    }
    ngAfterViewInit() {
       
      this.log(`ngAfterViewInit`);
    }
    ngAfterViewChecked() {
       
      this.log(`ngAfterViewChecked`);
    }
    ngAfterContentInit() {
       
      this.log(`ngAfterContentInit`);
    }
    ngAfterContentChecked() {
       
      this.log(`ngAfterContentChecked`);
    }
 
    private log(msg: string) {
        console.log(this.count + ". " + msg);
        this.count++;
    }
}
И используем этот компонент в главном компоненте:


import { Component} from '@angular/core';
      
@Component({
    selector: 'my-app',
    template: `<child-comp [name]="name"></child-comp>
                <input type="text" [(ngModel)]="name" />`
})
export class AppComponent{ 
     name:string="Tom";
}
И при обращении к приложению мы получим следующую цепочку вызовов.
====================================================================
====================================================================
................Шаблонные переменные, ViewChild и ContentChild.........
.......................................................................


Шаблонные переменные позволяют определить некоторые переменные внутри шаблона компонента и затем ссылаться к этим переменным из этого же шаблона. Для определения подобных переменных применяется знак решетки (#). Например, определим шаблонную переменную userName в компоненте:


import { Component } from '@angular/core';
       
@Component({
    selector: 'my-app',
    template: `
                <p #userName>{{name}}</p>
                <p>{{userName.textContent}}</p>
                <input type="text" [(ngModel)]="name" />`
})
export class AppComponent { 
    name:string="Tom";
}
Определение переменной выглядит следующим образом:

1
<p #userName>{{name}}</p>
Определение переменной userName в элементе параграфа означает, что она будет представлять данный параграф, то есть элемент p разметки html. И далее мы можем обращаться к этому параграфу через данную переменную. Например, через свойство userName.textContent можно получить текстовое содержимое параграфа. При этом, если привязанное к параграфу значение переменной name изменится, то соответственно изменится и значение userName.textContent:

Локальные переменные в Angular2
При этом данную переменную мы можем использовать только внутри шаблона.

Использование шаблонных переменных открывает нам дополнительный способ взаимодействия между родительским и дочерним компонентом. Например, определим следующий дочерний компонент ChildComponent:


import { Component} from '@angular/core';
       
@Component({
    selector: 'child-comp',
    template: `<p>{{counter}}</p>`
})
export class ChildComponent{
     
    counter: number = 0;
    increment() { this.counter++; }
    decrement() { this.counter--; }
}
В этом компоненте определяется переменная счетчика counter. Для ее увеличения или уменьшения применяются методы increment и decrement.

В коде главного компонента будем вызывать дочерний компонент:


import { Component } from '@angular/core';
       
@Component({
    selector: 'my-app',
    template: `<child-comp #counter></child-comp>
                <button (click)="counter.increment()">+</button>
                <button (click)="counter.decrement()">-</button>`
})
export class AppComponent { }
В данном случае шаблонная переменная counter, определенная внутри тега <child-comp>, поэтому она будет представлять компонент ChildComponent.

Соответственно далее мы можем ссылаться к компоненту ChildComponent через эту переменную, например, установить для событий кнопок привязку к методам ChildComponent. В итоге по нажатию на кнопки в главном компоненте будут вызываться методы из дочернего компонента:

Локальные переменные в компонентах в Angular2
ViewChild
Однако шаблонные переменные имеют свои ограничения: они не могут применяться вне шаблона, даже в коде класса компонента. Например, мы не можем написать так:


import { Component} from '@angular/core';
       
@Component({
    selector: 'my-app',
    template: `<child-comp #counter></child-comp>
                <button (click)="increment()">+</button>
                <button (click)="decrement()">-</button>`
})
export class AppComponent { 
 
    increment() { this.counter++; }
    decrement() { this.counter--; }
}
Здесь для класса AppComponent свойства this.counter не существует - оно существует только для шаблона.

Чтобы все таки иметь возможность обращаться к методам и прочей функциональности дочернего компонента, надо использовать декоратор ViewChild. Так, изменим главный компонент следующим образом:


import { Component, ViewChild } from '@angular/core';
import { ChildComponent} from './child.component';
       
@Component({
    selector: 'my-app',
    template: `<child-comp></child-comp>
                <button (click)="increment()">+</button>
                <button (click)="decrement()">-</button>`
})
export class AppComponent { 
 
    @ViewChild(ChildComponent)
    private counterComponent: ChildComponent;
     
    increment() { this.counterComponent.increment(); }
    decrement() { this.counterComponent.decrement(); }
}
С помощью применения к нему декоратора ViewChild к свойству counterComponent мы устанавливаем, что это свойство будет содержать объект дочернего компонента, который внедряется через элемент <child-comp></child-comp>. И в этом случае мы уже можем не использовать шаблонные переменные в шаблоне.

Привязка ViewChild к шаблонным переменным
Несмотря на то, что выше мы не использовали переменные, тем не менее с помощью декоратора ViewChild также можно связать свойство и переменную из шаблона. Так, изменим код главного компонента:


import { Component, ViewChild, ElementRef } from '@angular/core';
       
@Component({
    selector: 'my-app',
    template: `<p #nameText>{{name}}</p>
               <p>{{nameText.textContent}}</p>
               <button (click)="change()">Изменить</button>`
})
export class AppComponent { 
 
    @ViewChild("nameText")
    nameParagraph: ElementRef;
     
    name: string = "Tom";
     
    change() { 
        console.log(this.nameParagraph.nativeElement.textContent); 
        this.nameParagraph.nativeElement.textContent = "hell";
    }
}
Здесь в шаблоне определяется переменная nameText, которая представляет код параграфа. А в декоратор ViewChild передается имя этой переменной. Поэтому свойство nameParagraph, к которому применяется декоратор, будет указывать на эту переменную nameText. Причем свойство nameParagraph представляет тип ElementRef, который используется для ссылки на элементы html.

По нажатию на кнопку выводится и изменяется текстовое содержимое этой переменной.

ContentChild
Кроме ViewChild для связи с шаблонными переменными мы можем применять другой декоратор - ContentChild. В какой ситуации он может понадобится? Допустим, в родительском компоненте определен следующий код:


import { Component} from '@angular/core';
       
@Component({
    selector: 'my-app',
    template: `<child-comp>
                    <h3 #headerContent>Добро пожаловать {{name}}!</h3>
               </child-comp>`
})
export class AppComponent { 
 
    name: string = "Tom";
}
Здесь определена переменная #headerContent, которая указывает на элемент заголовка h3.

Причем поскольку данные из родительского компонента передаются в дочерний напрямую, то для получения этих данных в дочернем компоненте будет использоваться элемент ng-content:


import { Component, ContentChild, ElementRef } from '@angular/core';
       
@Component({
    selector: 'child-comp',
    template: `<ng-content></ng-content>
               <button (click)="change()">Изменить</button>`
})
export class ChildComponent{ 
     
    @ContentChild("headerContent")
    header: ElementRef;
     
    change() { 
        console.log(this.header); 
        this.header.nativeElement.textContent = "Hell to world!"; 
    }
}
И как раз чтобы получить переменные, которые передаются с кодом через ng-content, дочерний компонент применяет декоратор ContentChild. В этот декоратор также передается название переменной. Само свойство декоратора также представляет объект ElementRef. И далее мы можем манипулировать этим объектом.
===============================================================================================
===============================================================================================
===============================================================================================
...................................Директивы...................................................

    

 
Директивы определяют набор инструкций, которые применяются при рендеринге html-кода. Директива представляет класс с директивными метаданными. В TypeScript для прикрепления метаданных к классу применяется декоратор @Directive.

В Angular есть три типа директив:

Компоненты: компонент по сути также является директивой, а декоратор @Component расширяет возможности декоратора @Directive с помощью добавления функционала по работе с шаблонами.

Атрибутивные: они изменяют поведение уже существующего элемента, к которому они применяются. Например, ngModel, ngStyle, ngClass

Структурные: они изменяют структуру DOM с помощью добавления, изменения или удаления элементов hmtl. Например, это директивы ngFor и ngIf

............................ngClass и ngStyle..........................................
////////////////////////////////ngClass///////////////////////////////////////////////
Директива ngClass позволяет определить набор классов, которые будут применяться к элементу. Например, определим следующий компонент:

import { Component} from '@angular/core';
       
@Component({
    selector: 'my-app',
    template: `<div [ngClass]="{verdanaFont:true}">
                    <h1>Hello Angular 2</h1>
                    <p [ngClass]="{segoePrintFont:true}">
                        Angular 5 представляет модульную архитектуру приложения
                    </p>
                </div>`,
    styles: [
        `.verdanaFont{font-size:13px; font-family:Verdana;}
        .segoePrintFont{font-size:14px; font-family:"Segoe Print";}`
    ]
})
export class AppComponent { }
В секции styles у компонента определены два класса, которые устанавливают различные стилевые свойства шрифта: verdanaFont и segoePrintFont.

В шаблоне для привязки класса к элементу применяется директива [ngClass]="{verdanaFont:true}". Эта директива принимает js-объект, в котором ключи - это названия классов. Этим названиям присваиваются булевые значения true (если класс применяется) и false (если класс не применяется). То есть в данном случае класс verdanaFont будет применяться ко всему блоку div.

Однако в блоке div есть параграф, и мы, допустим, хотим, чтобы к этому параграфу применялся другой класс. А по умолчанию вложенный параграф унаследует стили от родительского блока div и также применяет класс segoePrintFont, в котором можно переопределить унаследованные стили.

Директива ngClass в Angular 2
В качестве альтернативы мы можем использовать следующие выражения привязки:


<div [class.verdanaFont]="true">
    <h1>Hello Angular 5</h1>
    <p [class.verdanaFont]="false" [class.segoePrintFont]="true">
        Angular 5 представляет модульную архитектуру приложения
    </p>
</div>
Выражение [class.verdanaFont]="true" указывает, что класс verdanaFont будет применяться для данного элемента.

ngStyle
Директива ngStyle позволяет задать набор стилей, которые применяются к элементу. В качестве значения директива принимает js-объект, в котором ключи - названия свойств CSS:


import { Component} from '@angular/core';
       
@Component({
    selector: 'my-app',
    template: `<div [ngStyle]="{'font-size':'13px', 'font-family':'Verdana'}">
                    <h1>Hello Angular 5</h1>
                    <p [ngStyle]="{'font-size':'14px', 'font-family':'Segoe Print'}">
                        Angular 5 представляет модульную архитектуру приложения
                    </p>
                </div>`,
    styles: [
        `.verdanaFont{font-size:13px; font-family:Verdana;}
        .segoePrintFont{font-size:14px; font-family:"Segoe Print";}`
    ]
})
export class AppComponent { }
Аналогично для установки стилей можно применять свойства объекта style:


<div [style.fontSize]="'13px'" [style.fontFamily]="'Verdana'">
    <h1>Hello Angular 5</h1>
    <p [style.fontSize]="'14px'" [style.fontFamily]="'Segoe Print'">
        Angular 5 представляет модульную архитектуру приложения
    </p>
</div>
Динамическое изменение стилей
Директивы ngClass и ngStyle позволяют устанавливать привязку к выражениям, благодаря чему мы можем динамически менять стили или классы. Например:


import { Component} from '@angular/core';
       
@Component({
    selector: 'my-app',
    template: `<div [ngClass]="{invisible: visibility}">
                    <h1>Hello Angular 5</h1>
                    <p>
                        Angular 5 представляет модульную архитектуру приложения
                    </p>
                </div>
                <button (click)="toggle()">Toggle</button>`,
    styles: [ `.invisible{display:none;}`]
})
export class AppComponent { 
     
    visibility: boolean = true;
    // переключаем переменную
    toggle(){
        this.visibility=!this.visibility;
    }
}
Выражение [ngClass]="{invisible: visibility}" устанавливает для класса invisible привязку к значению переменной visibility. По нажатию на кнопку мы можем переключать это свойство, тем самым управляя видимостью блока.

В качестве альтернативы также можно было бы использовать следующее выражение:

1
<div [class.invisible]="visibility">
Либо также можно было бы написать так:

1
<div [style.display]="visibility==true?'block':'none'">

 
=============================================================================    
=============================================================================    
=============================================================================
......................Создание атрибутивных директив.........................
............................................................................    



    

 
Атрибутивные директивы меняют поведение элемента, к которому они применяются. Например, директива ngClass позволяет установить для элемента класс CSS. При этом сама директива применяется к элементу в виде атрибута:

1
<div [ngClass]="{verdanaFont:true}">
И при необходимости мы можем сами создавать какие-то свои директивы атрибутов для каких-то определенных целей. Итак, создадим свою директиву. Добавим в папку src/app новый файл, который назовем bold.directive.ts:

Создание директив в Angular и Typescript
Определим в файле bold.directive.ts следующий код:


import {Directive, ElementRef} from '@angular/core';
 
@Directive({
    selector: '[bold]'
})
export class BoldDirective{
     
    constructor(private elementRef: ElementRef){
         
        this.elementRef.nativeElement.style.fontWeight = "bold";
    }
}
Директива - это обычный класс на TS, к которому применяется декоратор Directive, соответственно нам надо импортировать эту директиву из "angular/core". Кроме того, здесь импортируется класс "ElementRef". Он представляет ссылку на элемент, к которому будет применяться директива.

При применении декоратора @Directive необходимо определить селектор CSS, с которым будет ассоциирована директива. Селектор CSS для атрибута должен определяться в квадратных скобках. В данном случае в качестве селектора выступает [bold].

Сам декоратор @Directive применяется к классу, который называется BoldDirective. Это собственно и есть класс директивы, который определяет ее логику.

Для получения элемента, к которому применяется данная директива, в классе определен конструктор, имеющий один параметр: private elementRef: ElementRef. Через этот параметр Angular будет передавать или инжектировать тот элемент из шаблона, в котором применяется директива.

Поскольку параметр определен с ключевым словом private, то для него будет создаваться одноименная приватная переменная, через которую мы можем получить объект ElementRef и произвести с ним какие-либо манипуляции. В частности, здесь идет обращение к вложенному свойству nativeElement, через которое у элемента устанавливается жирный шрифт:

1
this.elementRef.nativeElement.style.fontWeight = "bold";
Теперь возьмем код главного компонента и применим директиву:


import { Component} from '@angular/core';
 
@Component({
    selector: 'my-app',
    template: `<div>
                  <p bold>Hello Angular 2</p>
                  <p>Angular 2 представляет модульную архитектуру приложения</p>
               </div>`
})
export class AppComponent {}
Здесь определено два параграфа, и к первому из них применяется директива. Поскольку в коде директивы был определен селектор "[bold]", то чтобы ее применить, в коде элемента применяется данный селектор.

Но сама по себе директива не заработает. Нам еще надо ее подключить в модуле приложения - классе AppModule:


import { NgModule }      from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent }   from './app.component';
import { BoldDirective} from './bold.directive';
 
@NgModule({
    imports:      [ BrowserModule],
    declarations: [ AppComponent, BoldDirective],
    bootstrap:    [ AppComponent ]
})
export class AppModule { }
Как и компоненты, директивы также надо сначала импортировать из файла, где они объявлены:

1
import { BoldDirective} from './bold.directive';
Затем она добавляется в секцию declarations:

1
declarations: [ AppComponent, BoldDirective],
И если мы запустим приложение, то увидим применение директивы к первому параграфу:

Создание атрибутивных директив в Angular 2
Для управления стилизацией элемента выше этот элемента извлекался через объект ElementRef в конструкторе директивы, и у него устанавливались стилевые свойства. Однако гораздо удобнее для управления стилем использовать рендерер. Так, изменим директиву следующим образом:


import {Directive, ElementRef, Renderer2} from '@angular/core';
 
@Directive({
    selector: '[bold]'
})
export class BoldDirective{
     
    constructor(private elementRef: ElementRef, private renderer: Renderer2){
         
        this.renderer.setStyle(this.elementRef.nativeElement, "font-weight", "bold");
    }
}
Renderer2 представляет сервис, который также при вызове директивы автоматически передается в ее конструктор, и мы можем использовать данный сервис для стилизации элемента. А результат работы будет тот же, что и выше.

=====================================================================================
=====================================================================================
=====================================================================================
.......................Взаимодействие с пользователем................................
.....................................................................................



 
Кроме простой установки значений атрибутивная директива может взаимодействовать с пользователем. Для этого применяется декоратор HostListener.

Так, возьмем директиву BoldDirective из прошлой темы и добавим в нее взаимодействие с пользователем:



import {Directive, ElementRef, Renderer2, HostListener} from '@angular/core';
 
@Directive({
    selector: '[bold]'
})
export class BoldDirective{
     
    constructor(private element: ElementRef, private renderer: Renderer2){
         
        this.renderer.setStyle(this.element.nativeElement, "cursor", "pointer");
    }
     
    @HostListener("mouseenter") onMouseEnter() {
        this.setFontWeight("bold");
    }
 
    @HostListener("mouseleave") onMouseLeave() {
        this.setFontWeight("normal");
    }
 
    private setFontWeight(val: string) {
        this.renderer.setStyle(this.element.nativeElement, "font-weight", val);
    }
}
Декоратор @HostListener позволяет связать события DOM и методы директивы. В частности, в декоратор передается название события, по которому будет вызываться метод. В данном случае мы привязываем события mouseenter (наведения указателя мыши на элемент) и mouseleave (уведение указателя мыши с элемента) к методу setFontWeight(), который устанавливает стилевое свойство font-weight у элемента. Если мы наводим на элемент, то устанавливается выделение жирным. При отводе мыши выделение сбрасывается.

Кроме кода директивы менять больше ничего не надо, код компонента и модуля остаются теми же.

HostBinding
Еще один декоратор - HostBinding позволяет связать обычное свойство класса со свойством элемента, к которому применяется директива. Например, изменим код директивы следующим образом:



import {Directive, HostListener, HostBinding} from '@angular/core';
 
@Directive({
    selector: '[bold]'
})
export class BoldDirective{
     
    private fontWeight = "normal";
     
    @HostBinding("style.fontWeight") get getFontWeight(){
         
        return this.fontWeight;
    }
     
    @HostBinding("style.cursor") get getCursor(){
        return "pointer";
    }
     
    @HostListener("mouseenter") onMouseEnter() {
        this.fontWeight ="bold";
    }
 
    @HostListener("mouseleave") onMouseLeave() {
        this.fontWeight = "normal";
    }
}
Инструкция @HostBinding("style.fontWeight") get getFontWeight() связывает со свойством "style.fontWeight" значение, которое возвращается этим геттером getFontWeight. А он возвращает значение свойства fontWeight, которое также меняется при наведении указателя мыши.

Свойство host
Вместо применения декораторов HostListener и HostBinding для реагирования директивы на действия пользователя мы можем определить обработчики событий в декораторе Directive с помощью его свойства host. Так, перепишем директиву следующим образом:



import {Directive, ElementRef, Renderer2} from '@angular/core';
  
@Directive({
    selector: '[bold]',
    host: {
        '(mouseenter)': 'onMouseEnter()',
        '(mouseleave)': 'onMouseLeave()'
    }
})
export class BoldDirective{
      
    constructor(private element: ElementRef, private renderer: Renderer2){
          
        this.renderer.setStyle(this.element.nativeElement, "cursor", "pointer");
    }
     
    onMouseEnter(){
        this.setFontWeight("bold");
    }
    onMouseLeave(){
        this.setFontWeight("normal");
    }
    private setFontWeight(val: string) {
        this.renderer.setStyle(this.element.nativeElement, "font-weight", val);
    }
}
Результат работы директивы в данном случае будет аналогичен, только теперь все события и связанные с ними обработчики определяются с помощью параметра host:


host: {
    '(mouseenter)': 'onMouseEnter()',
    '(mouseleave)': 'onMouseLeave()'
}

===================================================================================
===================================================================================
===================================================================================
....................Получение параметров в директивах..............................
===================================================================================

    

 
Директива как и компонент может получать некоторые входные параметры извне. Для этого также используется декоратор Input. Итак, возьмем директиву BoldDirective из прошлой темы и, допустим, мы хотим, чтобы у текста при наведении также менялась высота шрифта. Но при этом чтобы нужную высоту шрифта можно было бы задать извне директивы. Для этого изменим ее следующим образом:


import {Directive, HostListener, Input, HostBinding, OnInit} from '@angular/core';
 
@Directive({
    selector: '[bold]'
})
export class BoldDirective implements OnInit{
     
    @Input() selectedSize = "18px";
    @Input() defaultSize = "16px";
     
    private fontSize : string;
    private fontWeight = "normal";
    ngOnInit(){
        this.fontSize = this.defaultSize;
    }
    constructor(){}
     
    @HostBinding("style.fontSize") get getFontSize(){
         
        return this.fontSize;
    }
     
    @HostBinding("style.fontWeight") get getFontWeight(){
         
        return this.fontWeight;
    }
     
    @HostBinding("style.cursor") get getCursor(){
        return "pointer";
    }
     
    @HostListener("mouseenter") onMouseEnter() {
        this.fontWeight ="bold";
        this.fontSize = this.selectedSize;
    }
 
    @HostListener("mouseleave") onMouseLeave() {
        this.fontWeight = "normal";
        this.fontSize = this.defaultSize;
    }
}
В данном случае определяются два входных параметра:

1
2
@Input() selectedSize = "18px";
@Input() defaultSize = "16px";
Параметр selectedSize отвечает за высоту шрифта при наведении мыши, а в параметр defaultSize устанавливает высоту шрифта, когда указатель мыши находится вне границ элемента.

Кроме того, чтобы задействовать значение defaultSize при запуске приложения, реализуется метод ngOnInit.

Теперь задействуем эти параметры, изменив код компонента:


import { Component} from '@angular/core';
 
@Component({
    selector: 'my-app',
    template: `<div>
                  <p bold [selectedSize]="'28px'" [defaultSize]="'14px'">Hello Angular 2</p>
                  <p>Angular 2 представляет модульную архитектуру приложения</p>
               </div>`
})
export class AppComponent {}
При применении директивы мы можем указать все входные параметры и их значения:

1
<p bold [selectedSize]="'28px'" [defaultSize]="'14px'">Hello Angular 2</p>
При этом названия параметров заключаются в квадратные скобки, а их значения дополнительно заключаются в одинарные кавычки.

И при наведении на элемент автоматически будет меняться также и высота шрифта:

Input Parameters in Directive in Angular 2
Теперь пойдем дальше и изменим первый входной параметр:

1
@Input("bold") selectedSize = "18px";
Здесь в декоратор Input передается селектор директивы - bold. Поэтому чтобы установить этот параметр в шаблоне компонента мы можем напрямую использовать имя директивы:

1
<p [bold]="'28px'" [defaultSize]="'14px'">Hello Angular 2</p>

 


    

 

 

 





 


    



 




 

 

 



 





 

 

 







 


    

 

 





 


    

 

 

 





 


  

 




 


 





 

    

 

 

 


 

 

 





 


 


    

 

  

 




 

 

 



 





    

 

 

 





